# QQ 机器人端开发指南

本文档描述 QQ 机器人端需要实现的功能，以便与 SeekYourGuild 监控系统对接。

## 概述

机器人端负责监听 QQ 群事件，并将数据上报到监控服务器。

## 配置信息

机器人端需要配置以下信息：

```yaml
# 监控服务器配置
monitor:
  # 服务器地址
  base_url: "http://your-server:8080"
  # API 密钥（与服务端配置一致）
  api_key: "your-secret-api-key"
  # 监控的群号列表
  groups:
    - 123456789
```

## 事件监听与上报

### 1. 成员加入事件

**触发时机**: 当有新成员加入监控的群时

**上报接口**: `POST /api/report/member`

**上报数据**:

```json
{
  "group_id": 群号,
  "event_type": "join",
  "member": {
    "user_id": 新成员QQ号,
    "nickname": "新成员昵称",
    "card": "群名片（如有）"
  },
  "timestamp": 事件发生的Unix时间戳
}
```

---

### 2. 成员退出事件

**触发时机**: 当成员主动退出监控的群时

**上报接口**: `POST /api/report/member`

**上报数据**:

```json
{
  "group_id": 群号,
  "event_type": "leave",
  "member": {
    "user_id": 退出成员QQ号,
    "nickname": "成员昵称",
    "card": "群名片"
  },
  "timestamp": 事件发生的Unix时间戳
}
```

---

### 3. 成员被踢事件

**触发时机**: 当成员被管理员/群主踢出监控的群时

**上报接口**: `POST /api/report/member`

**上报数据**:

```json
{
  "group_id": 群号,
  "event_type": "kick",
  "member": {
    "user_id": 被踢成员QQ号,
    "nickname": "成员昵称",
    "card": "群名片"
  },
  "operator_id": 操作者QQ号,
  "timestamp": 事件发生的Unix时间戳
}
```

---

### 4. 群消息事件

**触发时机**: 当监控群内有人发送消息时

**上报接口**: `POST /api/report/message`

**上报数据**:

```json
{
  "group_id": 群号,
  "user_id": 发送者QQ号,
  "message_id": "消息唯一ID",
  "message_type": "消息类型",
  "content_length": 消息内容长度,
  "timestamp": 消息发送的Unix时间戳
}
```

**消息类型说明**:
| 类型 | 说明 |
|------|------|
| `text` | 纯文本消息 |
| `image` | 图片消息 |
| `file` | 文件消息 |
| `other` | 其他类型（语音、视频、表情等） |

> ⚠️ 注意：不要上报消息的具体内容，仅统计消息数量和类型。

---

### 5. 心跳上报

**触发时机**: 定时上报（建议每 60 秒一次）

**上报接口**: `POST /api/report/heartbeat`

**上报数据**:

```json
{
  "group_id": 群号,
  "bot_id": 机器人QQ号,
  "status": "online",
  "timestamp": 当前Unix时间戳
}
```

**状态说明**:
| 状态 | 说明 |
|------|------|
| `online` | 机器人在线正常运行 |
| `offline` | 机器人离线（在关闭时发送） |

---

### 6. 成员列表全量同步

**触发时机**:

- 机器人启动时
- 每天固定时间（如凌晨 3 点）
- 收到服务端同步请求时（可选）

**上报接口**: `POST /api/report/members`

**上报数据**:

```json
{
  "group_id": 群号,
  "members": [
    {
      "user_id": 成员QQ号,
      "nickname": "成员昵称",
      "card": "群名片",
      "role": "角色",
      "join_time": 入群时间戳
    }
  ],
  "timestamp": 当前Unix时间戳
}
```

**角色说明**:
| 角色 | 说明 |
|------|------|
| `owner` | 群主 |
| `admin` | 管理员 |
| `member` | 普通成员 |

---

## 请求规范

### 请求头

所有请求必须携带以下请求头：

```
Content-Type: application/json
Authorization: Bearer <API_KEY>
```

### 响应处理

**成功响应**:

```json
{
  "code": 0,
  "message": "success"
}
```

**错误响应**:

```json
{
  "code": 错误码,
  "message": "错误描述"
}
```

**错误码说明**:
| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| 0 | 成功 | - |
| 1001 | 参数错误 | 检查请求体格式 |
| 1002 | 认证失败 | 检查 API Key |
| 2001 | 数据库错误 | 稍后重试 |
| 3001 | 请求频率超限 | 降低请求频率 |

---

## 实现建议

### 错误重试

- 网络错误或服务端错误时，应实现指数退避重试
- 建议最大重试 3 次，间隔 1s、2s、4s

### 消息去重

- 使用消息 ID 进行去重，避免重复上报

### 本地缓存

- 当服务端不可用时，将数据缓存到本地
- 服务端恢复后批量补报

### 日志记录

- 记录所有上报请求和响应
- 便于排查问题

---

## 代码示例（伪代码）

```python
# 初始化
monitor_url = "http://your-server:8080"
api_key = "your-secret-api-key"
watch_groups = [123456789]

# 请求头
headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {api_key}"
}

# 成员加入事件处理
def on_member_join(event):
    if event.group_id not in watch_groups:
        return

    data = {
        "group_id": event.group_id,
        "event_type": "join",
        "member": {
            "user_id": event.user_id,
            "nickname": event.nickname,
            "card": event.card or ""
        },
        "timestamp": int(time.time())
    }

    post(f"{monitor_url}/api/report/member", headers=headers, json=data)

# 消息事件处理
def on_group_message(event):
    if event.group_id not in watch_groups:
        return

    msg_type = "text"
    if event.has_image:
        msg_type = "image"
    elif event.has_file:
        msg_type = "file"

    data = {
        "group_id": event.group_id,
        "user_id": event.user_id,
        "message_id": event.message_id,
        "message_type": msg_type,
        "content_length": len(event.raw_message),
        "timestamp": int(time.time())
    }

    post(f"{monitor_url}/api/report/message", headers=headers, json=data)

# 心跳任务
def heartbeat_task():
    while True:
        for group_id in watch_groups:
            data = {
                "group_id": group_id,
                "bot_id": bot.self_id,
                "status": "online",
                "timestamp": int(time.time())
            }
            post(f"{monitor_url}/api/report/heartbeat", headers=headers, json=data)

        time.sleep(60)  # 每60秒心跳一次

# 启动时同步成员列表
def sync_members():
    for group_id in watch_groups:
        members = bot.get_group_member_list(group_id)
        data = {
            "group_id": group_id,
            "members": [
                {
                    "user_id": m.user_id,
                    "nickname": m.nickname,
                    "card": m.card,
                    "role": m.role,
                    "join_time": m.join_time
                }
                for m in members
            ],
            "timestamp": int(time.time())
        }
        post(f"{monitor_url}/api/report/members", headers=headers, json=data)
```

---

## 常见问题

### Q: 消息量很大，会不会给服务器造成压力？

A: 服务器采用异步处理和聚合统计，可以承受较大的消息量。如果群非常活跃（如每秒数十条消息），可以考虑在机器人端进行采样或批量上报。

### Q: 服务器断开后数据会丢失吗？

A: 建议在机器人端实现本地缓存，服务器恢复后补报数据。

### Q: 需要上报所有群的数据吗？

A: 只需要上报配置中指定的群。避免不必要的数据上报。
